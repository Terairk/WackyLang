Ideas on what to do as part of extension:

1: rewrite top-to-bottom the whole process to make it more type-driven and easier to refactor:
> frontend needs to produce control-flow graph
 > may use type-driven secondary representation using GADTs??

> middle-end needs to change how it is written to be more like LLVM
 > need to add more "instructions" on metadata, may be useful for e.g. call-stack metadata for a potential GC
 > it might also benifit from modeling itself as GADT
 > needs to
 > it may be advantageous to add effect-tracking types to the operations, as right now the side-effects are assumed and implicit
  > so e.g. a zero-sized marker type that can be a "witness" to a certain action taking place, and the only way other parts of the
  > API will continue working is if they consume this "witness" type as an argument. And the only way to make this witness type,
  > by construction, would be to so the action that it corresponds to.
   > It makes developement much more type-driven, but avoids bloat because these are zero-sized parameters and can be optimized away

2: optimizations
> the CFG from above should be a part of it
> any other extensions should be easier when the mid-ir is more clean

3: GC
> research on how to make GC interop with call-stack via FFI
>> checking registers aswell?
>> how to make GC procedure not create additional call_stack?? e.g. inlining it
>> can we use third party GC impls??

4: Bi-directional typechecking
> may allow for more rich typesystem and other extension
