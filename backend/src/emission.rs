use crate::assembly_ast::{
    AsmBinaryOperator, AsmFunction, AsmInstruction, AsmProgram, AsmUnaryOperator, AssemblyType,
    CondCode, Operand, Register,
};

// TODO: this code was mostly generated by an LLM, please have mercy on it
// Also its very wrong, I'm so sorry, most of these are just placeholders
// and will definitely need to be looked at again
// Also it doesn't use the GenFlags struct

pub struct AssemblyFormatter;

impl AssemblyFormatter {
    // Format an entire program by printing each function.

    #[inline]
    pub fn format_program(program: &AsmProgram) -> String {
        let mut output = String::new();
        for func in &program.asm_functions {
            output.push_str(&Self::format_function(func));
        }
        output
    }
    // Format a single function. This prints any global/external directives,
    // a label for the function, the instructions and adds a blank line at the end.
    #[inline]
    pub fn format_function(func: &AsmFunction) -> String {
        let mut lines = Vec::new();
        if func.global {
            // Global directives start with a dot, so they will have no indent.
            lines.push(format!(".global {}", func.name));
        }
        // Print function label (ends with ":" so we omit the indent).
        lines.push(format!("{}:", func.name));
        for inst in &func.instructions {
            let inst_line = Self::format_instruction(inst);
            // For each instruction line, apply the proper indentation.
            for single_line in inst_line.lines() {
                lines.push(Self::apply_indentation(single_line));
            }
        }
        // Ensure at least one blank line at the end of the function.
        lines.push(String::new());
        let mut result = lines.join("\n");
        result.push('\n');
        result
    }

    // Format a single instruction by matching on the AST enum.
    #[inline]
    pub fn format_instruction(inst: &AsmInstruction) -> String {
        match inst {
            AsmInstruction::Mov { typ, src, dst } => {
                let suffix = Self::assembly_type_suffix(typ);
                let src_str = Self::format_operand(src);
                let dst_str = Self::format_operand(dst);
                format!("mov{} {}, {}", suffix, src_str, dst_str)
            }
            AsmInstruction::MovZeroExtend {
                src_type,
                dst_type,
                src,
                dst,
            } => {
                // Using the destination type to determine the suffix.
                let suffix = Self::assembly_type_suffix(dst_type);
                let src_str = Self::format_operand(src);
                let dst_str = Self::format_operand(dst);
                format!("movzx{} {}, {}", suffix, src_str, dst_str)
            }
            AsmInstruction::Lea { src, dst } => {
                let src_str = Self::format_operand(src);
                let dst_str = Self::format_operand(dst);
                format!("lea {}, {}", src_str, dst_str)
            }
            AsmInstruction::Unary {
                operator,
                typ,
                operand,
            } => {
                let suffix = Self::assembly_type_suffix(typ);
                let operand_str = Self::format_operand(operand);
                let op = Self::format_unary_operator(operator);
                format!("{}{} {}", op, suffix, operand_str)
            }
            AsmInstruction::Binary {
                operator,
                typ,
                op1,
                op2,
            } => {
                let suffix = Self::assembly_type_suffix(typ);
                let op1_str = Self::format_operand(op1);
                let op2_str = Self::format_operand(op2);
                let op = Self::format_binary_operator(operator);
                format!("{}{} {}, {}", op, suffix, op1_str, op2_str)
            }
            AsmInstruction::Cmp { typ, op1, op2 } => {
                let suffix = Self::assembly_type_suffix(typ);
                let op1_str = Self::format_operand(op1);
                let op2_str = Self::format_operand(op2);
                format!("cmp{} {}, {}", suffix, op1_str, op2_str)
            }
            AsmInstruction::Idiv(op) => {
                let op_str = Self::format_operand(op);
                format!("idiv {}", op_str)
            }
            AsmInstruction::Cdq => "cdq".to_string(),
            AsmInstruction::Jmp(label) => format!("jmp {}", label),
            AsmInstruction::JmpCC { condition, label } => {
                let cond = Self::format_cond_code(condition);
                format!("j{} {}", cond, label)
            }
            AsmInstruction::SetCC { condition, operand } => {
                let cond = Self::format_cond_code(condition);
                let op_str = Self::format_operand(operand);
                format!("set{} {}", cond, op_str)
            }
            AsmInstruction::Label(name) => format!("{}:", name),
            AsmInstruction::AllocateStack(bytes) => {
                // In AT&T syntax, stack allocation is often performed by subtracting from %rsp.
                format!("subq ${}, %rsp", bytes)
            }
            AsmInstruction::Push(op) => {
                let op_str = Self::format_operand(op);
                format!("push {}", op_str)
            }
            AsmInstruction::Call(name) => format!("call {}", name),
            AsmInstruction::Ret => "ret".to_string(),
        }
    }

    /// Return the appropriate suffix for the given AssemblyType.
    /// (e.g. "b" for byte, "l" for longword, "q" for quadword)
    pub fn assembly_type_suffix(typ: &AssemblyType) -> &'static str {
        match typ {
            AssemblyType::Byte => "b",
            AssemblyType::Longword => "l",
            AssemblyType::Quadword => "q",
            AssemblyType::ByteArray { .. } => "b", // Default fallback for byte arrays
        }
    }

    /// Format an operand into its AT&T assembly representation.
    pub fn format_operand(op: &Operand) -> String {
        match op {
            Operand::Imm(val) => format!("${}", val),
            Operand::Reg(reg) => Self::format_register(reg),
            Operand::Pseudo(name) => name.clone(),
            Operand::Memory(reg, offset) => {
                // Format as: offset(%reg) (with no offset if the value is 0)
                let reg_str = Self::format_register(reg);
                if *offset == 0 {
                    format!("({})", reg_str)
                } else {
                    format!("{}({})", offset, reg_str)
                }
            }
            Operand::Data(label, offset) => {
                // RIP-relative addressing for data.
                if *offset == 0 {
                    format!("{}(%rip)", label)
                } else {
                    format!("{}+{}(%rip)", label, offset)
                }
            }
            Operand::PseudoMem(name, offset) => {
                // Similar convention as for Data.
                if *offset == 0 {
                    format!("{}(%rip)", name)
                } else {
                    format!("{}+{}(%rip)", name, offset)
                }
            }
            Operand::Indexed { base, index, scale } => {
                // Format: (base, index, scale)
                let base_str = Self::format_register(base);
                let index_str = Self::format_register(index);
                format!("({},{},{})", base_str, index_str, scale)
            }
            Operand::Stack(offset) => {
                // Using %rbp as the base pointer for a stack reference.
                format!("{}(%rbp)", offset)
            }
        }
    }

    /// Format a register – adds a "%" prefix and maps our enum to the 64-bit register names.
    pub fn format_register(reg: &Register) -> String {
        let reg_str = match reg {
            Register::AX => "rax",
            Register::CX => "rcx",
            Register::DX => "rdx",
            Register::DI => "rdi",
            Register::SI => "rsi",
            Register::R8 => "r8",
            Register::R9 => "r9",
            Register::R10 => "r10",
            Register::R11 => "r11",
            Register::SP => "rsp",
            Register::BP => "rbp",
        };
        format!("%{}", reg_str)
    }

    /// Format the binary operator as the proper mnemonic.
    pub fn format_binary_operator(op: &AsmBinaryOperator) -> &'static str {
        match op {
            AsmBinaryOperator::Add => "add",
            AsmBinaryOperator::Sub => "sub",
            AsmBinaryOperator::Mult => "imul", // AT&T multiplication
            AsmBinaryOperator::And => "and",
            AsmBinaryOperator::Or => "or",
            AsmBinaryOperator::Xor => "xor",
            AsmBinaryOperator::Shl => "sal", // shift left (sal is used in AT&T)
            AsmBinaryOperator::ShrTwoOp => "shr",
        }
    }

    /// Format the unary operator as the proper mnemonic.
    pub fn format_unary_operator(op: &AsmUnaryOperator) -> &'static str {
        match op {
            AsmUnaryOperator::Neg => "neg",
            AsmUnaryOperator::Not => "not",
            AsmUnaryOperator::Shr => "shr",
            AsmUnaryOperator::Len => "len", // pseudo operation – adjust as needed
            AsmUnaryOperator::Ord => "ord", // pseudo
            AsmUnaryOperator::Chr => "chr", // pseudo
        }
    }

    /// Map your condition codes to the AT&T conditional suffix.
    pub fn format_cond_code(cc: &CondCode) -> &'static str {
        match cc {
            CondCode::E => "e",
            CondCode::NE => "ne",
            CondCode::G => "g",
            CondCode::GE => "ge",
            CondCode::L => "l",
            CondCode::LE => "le",
            CondCode::A => "a",
            CondCode::AE => "ae",
            CondCode::B => "b",
            CondCode::BE => "be",
        }
    }

    /// Apply indentation rules to a line:
    /// - If the line starts with a dot (e.g. directives) or ends with ":" (labels), do not indent.
    /// - Otherwise, indent with 4 spaces.
    pub fn apply_indentation(line: &str) -> String {
        if line.is_empty() {
            return line.to_string();
        }
        if line.starts_with('.') || line.ends_with(':') {
            line.to_string()
        } else {
            format!("    {}", line)
        }
    }
}
